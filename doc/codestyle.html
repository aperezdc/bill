<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title>Code style guidelines</title>
<meta name="author" content="Adrian Perez &lt;aperez&#64;igalia.com&gt;" />
<link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div class="document" id="code-style-guidelines">
<h1 class="title">Code style guidelines</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Adrian Perez &lt;<a class="reference" href="mailto:aperez&#64;igalia.com">aperez&#64;igalia.com</a>&gt;</td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">GPL v2</td>
</tr>
</tbody>
</table>
<div class="abstract topic">
<p class="topic-title first">Abstract</p>
<p>Provides general guidelines on how to write and organize shell
code in general and when using the Bill library in particular.</p>
</div>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#shell-independent-tips" id="id3" name="id3">Shell-independent tips</a><ul>
<li><a class="reference" href="#quoting" id="id4" name="id4">Quoting</a><ul>
<li><a class="reference" href="#exceptions" id="id5" name="id5">Exceptions</a></li>
<li><a class="reference" href="#single-quotes" id="id6" name="id6">Single quotes</a></li>
</ul>
</li>
<li><a class="reference" href="#structured-programming" id="id7" name="id7">Structured programming</a></li>
<li><a class="reference" href="#fork-exec" id="id8" name="id8">fork+exec</a></li>
<li><a class="reference" href="#internal-commands" id="id9" name="id9">Internal commands</a></li>
<li><a class="reference" href="#avoid-using-backticks" id="id10" name="id10">Avoid using backticks</a></li>
<li><a class="reference" href="#last-things-occur-last" id="id11" name="id11">Last things occur... last</a></li>
</ul>
</li>
<li><a class="reference" href="#bashisms" id="id12" name="id12">“Bashisms”</a><ul>
<li><a class="reference" href="#locality-is-good" id="id13" name="id13">Locality is good</a></li>
<li><a class="reference" href="#cleaning-up" id="id14" name="id14">Cleaning up</a></li>
<li><a class="reference" href="#reading-file-contents" id="id15" name="id15">Reading file contents</a></li>
<li><a class="reference" href="#arrays" id="id16" name="id16">Arrays</a></li>
<li><a class="reference" href="#built-in-trick-galore" id="id17" name="id17">Built-in trick galore</a><ul>
<li><a class="reference" href="#printf-v" id="id18" name="id18">printf -v</a></li>
<li><a class="reference" href="#printf-q" id="id19" name="id19">printf %q</a></li>
<li><a class="reference" href="#caller" id="id20" name="id20">caller</a></li>
<li><a class="reference" href="#declare" id="id21" name="id21">declare</a></li>
</ul>
</li>
<li><a class="reference" href="#use-the-source-luke" id="id22" name="id22">Use the <em>source</em>, Luke</a></li>
</ul>
</li>
<li><a class="reference" href="#philosophy-basics" id="id23" name="id23">Philosophy basics</a></li>
</ul>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id3" id="shell-independent-tips" name="shell-independent-tips">Shell-independent tips</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id4" id="quoting" name="quoting">Quoting</a></h2>
<blockquote>
<p>Just in terms of allocation of time resources, religion is not very
efficient. There's a lot more I could be doing on a Sunday morning.</p>
<p class="attribution">&mdash;Bill Gates</p>
</blockquote>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use always double-quotes to enclose variable expansions. Unless you
are <em>really</em> sure that you do not want them.</p>
</div>
<p>You should be aware that <em>apparently</em> excessive quoting is not only allowed
in shell code, but even desirable.</p>
<p>Shells use quoting to allow passing characters which usually would need to
be escaped in a more convenient way (e.g. spaces). Compare the following and
decide which do you prefer:</p>
<div class="highlight"><pre>ls /path/to<span class="se">\ </span>somwhere/with<span class="se">\ </span>embedded<span class="se">\ </span>spaces
ls <span class="s2">&quot;/path/to somwhere/with embedded spaces&quot;</span>
</pre></div>
<p>As you can see, you can save some typing, and it makes code clearer. Quoting
is very important when using variables, because expanding an unquoted
variable will split it at spaces (more exactly: using the first character of
the <tt class="docutils literal"><span class="pre">IFS</span></tt> variable), which is not always what you want. Enclosing
a variable into double quotes instructs the shell not to perform splitting.
The following loop will print out three lines, one character per line:</p>
<div class="highlight"><pre><span class="nv">data</span><span class="o">=</span><span class="s1">&#39;a b c&#39;</span>
<span class="k">for </span>item in <span class="nv">$data</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nb">echo</span> <span class="nv">$item</span>
<span class="k">done</span>
</pre></div>
<p>But using quotes when expanding the <tt class="docutils literal"><span class="pre">data</span></tt> variable, the same loop will
print only a single line:</p>
<div class="highlight"><pre><span class="nv">data</span><span class="o">=</span><span class="s1">&#39;a b c&#39;</span>
<span class="k">for </span>item in <span class="s2">&quot;$data&quot;</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nb">echo</span> <span class="nv">$item</span>
<span class="k">done</span>
</pre></div>
<p>Subtle may appear due to due to missing quotes, and in general you will
<em>always</em> want to quote variable expansions.</p>
<div class="section">
<h3><a class="toc-backref" href="#id5" id="exceptions" name="exceptions">Exceptions</a></h3>
<p>There are some cases where quoting is not necessary at all:</p>
<ul>
<li><p class="first">When assigning one variable the contents of another. The shell parser
knows about this case and will always do the right thing. This includes
expressions in the form <tt class="docutils literal"><span class="pre">a=$b</span></tt>:</p>
<div class="highlight"><pre><span class="nv">b</span><span class="o">=</span><span class="s1">&#39;What the heck? - said the penguin&#39;</span>
<span class="nv">a</span><span class="o">=</span><span class="s2">&quot;$b&quot;</span>  <span class="c"># This works, extra quoting does not harm</span>
<span class="nv">a</span><span class="o">=</span><span class="nv">$b</span>    <span class="c"># Good one, too: this is just an assignment</span>
</pre></div>
</li>
<li><p class="first">When assigning a variable the output of a command. Explanation is the same
as for the previous entry, as the shell knows how to do <tt class="docutils literal"><span class="pre">a=$(pwd)</span></tt> right:</p>
<div class="highlight"><pre><span class="nv">a</span><span class="o">=</span><span class="s2">&quot;$(pwd)&quot;</span>  <span class="c"># Works. Did I say extra quoting does not harm?</span>
<span class="nv">a</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>    <span class="c"># No problem, no ambiguity in the expression.</span>
</pre></div>
</li>
<li><p class="first">When you really want to split things out. For example when gathering
command line options in a variable which will be passed to a command:</p>
<div class="highlight"><pre><span class="nv">flags</span><span class="o">=</span><span class="s2">&quot;-a&quot;</span>
<span class="nv">flags</span><span class="o">=</span><span class="s2">&quot;$flags --verbose&quot;</span>
<span class="o">[</span> -o /some/file <span class="o">]</span> || <span class="nv">flags</span><span class="o">=</span><span class="s2">&quot;$flags --output /some/file&quot;</span>

run_command <span class="nv">$flags</span>
</pre></div>
<p>It is okay to omit quotes here, but if you are using Bash, you better
would be using <a class="reference" href="#arrays">arrays</a>.</p>
</li>
<li><p class="first">When using <tt class="docutils literal"><span class="pre">[[</span></tt> instead of <tt class="docutils literal"><span class="pre">[</span></tt> in Bash. The <tt class="docutils literal"><span class="pre">[[</span></tt> built-in is defined
in the shell grammar and it does expansion “properly” because it is not
a command:</p>
<div class="highlight"><pre><span class="k">if</span> <span class="o">[[</span> :<span class="nv">$PATH</span>: <span class="o">=</span> *:/usr/bin:* <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">    </span><span class="nb">echo</span> <span class="s1">&#39;$PATH contains /usr/bin&#39;</span>
<span class="k">fi</span>
</pre></div>
</li>
</ul>
<p>Sometimes it is really needed to split variable contents, but bear in mind
that you usually are perfectly aware of that situations, so as a rule of
thumb <em>do</em> always quote your variables. As an example, the following
function will iterate over elements in a string separated by a given
separator (for example the <tt class="docutils literal"><span class="pre">PATH</span></tt> environment variable):</p>
<div class="highlight"><pre>print_list_items <span class="o">()</span>
<span class="o">{</span>
    <span class="nb">local </span><span class="nv">item</span><span class="o">=</span> <span class="nv">old_IFS</span><span class="o">=</span><span class="nv">$IFS</span>  <span class="c"># Save the current separator characters.</span>
    <span class="nv">IFS</span><span class="o">=</span><span class="nv">$1</span>

    <span class="k">for </span>item in <span class="nv">$2</span> ; <span class="k">do</span>
<span class="k">        </span><span class="nb">echo</span> <span class="s2">&quot;$item&quot;</span>
    <span class="k">done</span>

<span class="k">    </span><span class="nv">IFS</span><span class="o">=</span><span class="nv">$old_IFS</span>              <span class="c"># Restore separators.</span>
<span class="o">}</span>

print_list_items <span class="s1">&#39;:&#39;</span> <span class="s2">&quot;$PATH&quot;</span>
</pre></div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id6" id="single-quotes" name="single-quotes">Single quotes</a></h3>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use single quotes to enclose string literals.</p>
</div>
<p>Text enclosed in single quotes is <em>never</em> interpreted by the shell. The only
character which needs to be escaped is the quote character itself: all the
other characters, even carriage returns, will be part of the string. This
makes them a great feature for defining multi-line strings.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id7" id="structured-programming" name="structured-programming">Structured programming</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use shell functions to organize your code, as you would do in
other programming languages.</p>
</div>
<p>Clean and structured code is a lot easier to read and maintain than
unstructured “spaghetti” mash-ups. All decent-enough shells have a way of
defining shell functions. Also, writing functions is the first step needed
to write modular, reusable code.</p>
<p>Using shell functions instead of separate scripts has also the advantage of
avoiding calling <a class="reference" href="#fork-exec">fork+exec</a> when invoking them.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id8" id="fork-exec" name="fork-exec">fork+exec</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Avoid calling external commands when possible, especially
inside tight loops.</p>
</div>
<p>Launching external commands from the shell incurs in calling the
<a class="reference" href="http://linux.die.net/man/2/fork">fork()</a> and
<a class="reference" href="http://linux.die.net/man/3/exec">exec()</a> system calls. The first
one duplicates the running process into a new child process with its own
identifier, memory area, open file descriptors... The second one replaces
that new process with the code of the program being run. Although this is
done quite efficiently in recent operating systems, it is far more work
than calling <a class="reference" href="#internal-commands">internal commands</a> defined by the shell.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id9" id="internal-commands" name="internal-commands">Internal commands</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use shell built-in commands whenever possible.</p>
</div>
<p>Most shells include implementations for a number of usual commands in it,
thus avoiding expensive <a class="reference" href="#fork-exec">fork+exec</a> operations. Sometimes built-in commands
are even a superset of the standard ones and include extra features.</p>
<p>Commands eligible for such implementations are:</p>
<pre class="literal-block">
:
[
echo
printf
test
true
false
pwd
kill
</pre>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="avoid-using-backticks" name="avoid-using-backticks">Avoid using backticks</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use <tt class="docutils literal"><span class="pre">$(command)</span></tt> (POSIX command expansion) instead of
<tt class="docutils literal"><span class="pre">`command`</span></tt> (traditional backtick expansion).</p>
</div>
<p>Use always <tt class="docutils literal"><span class="pre">$(</span> <span class="pre">)</span></tt> for command expansion, <em>always</em>. There is no reason to
keep using backticks (<tt class="docutils literal"><span class="pre">`</span></tt>) because functionality is exactly the same, but
the firs method is more powerful. The nasty thing about backticks is that
you cannot nest them, like in the following example:</p>
<div class="highlight"><pre><span class="c"># Will not work: the shell believes the command is &quot;grep foo&quot;</span>
<span class="c"># (from the first to the second backtick)</span>
<span class="nv">output</span><span class="o">=</span><span class="sb">`</span>grep foo <span class="sb">`</span>find /usr/share/doc -type f -name <span class="s1">&#39;*.txt&#39;</span><span class="sb">``</span>
</pre></div>
<p>But it will work like a charm when using the POSIX variant:</p>
<div class="highlight"><pre><span class="c"># This works, POSIX command expansion works great!</span>
<span class="nv">output</span><span class="o">=</span><span class="k">$(</span>grep foo <span class="k">$(</span>find /usr/share/doc -type f -name <span class="s1">&#39;*.txt&#39;</span><span class="k">))</span>
</pre></div>
<p>In short: beware of backticks!</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="last-things-occur-last" name="last-things-occur-last">Last things occur... last</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">If the exit status of a function is the result of executing a
command, just leave that command at the end of the function.</p>
</div>
<p>At a first attempt one may be tempted to write “defensive” code that ensures
that the exit status is always set before exiting a functions:</p>
<div class="highlight"><pre>string_is_magic <span class="o">()</span>
<span class="o">{</span>
    <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$1&quot;</span> <span class="o">=</span> <span class="s2">&quot;magic&quot;</span> <span class="o">]</span> ; <span class="k">then</span>
<span class="k">        return </span>0
    <span class="k">else</span>
<span class="k">        return </span>1
    <span class="k">fi</span>
<span class="o">}</span>
</pre></div>
<p>The code is correct and will work as expected, but it is hairy and has not
pleasant aesthetics. As a first refinement one may found that the following
works:</p>
<div class="highlight"><pre>string_is_magic <span class="o">()</span> <span class="o">{</span>
    <span class="o">[</span> <span class="s2">&quot;$1&quot;</span> <span class="o">=</span> <span class="s2">&quot;magic&quot;</span> <span class="o">]</span>
    <span class="k">return</span> <span class="nv">$?</span>
<span class="o">}</span>
</pre></div>
<p>Be aware that the last command always sets the exit status of the <em>entire
function</em>, so the optimal way of implementing this function is the
following:</p>
<div class="highlight"><pre>string_is_magic <span class="o">()</span> <span class="o">{</span>
    <span class="o">[</span> <span class="s2">&quot;$1&quot;</span> <span class="o">=</span> <span class="s2">&quot;magic&quot;</span> <span class="o">]</span>
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id12" id="bashisms" name="bashisms">“Bashisms”</a></h1>
<p><a class="reference" href="http://www.gnu.org/software/bash">Bash</a> is a <em>better</em> <tt class="docutils literal"><span class="pre">sh</span></tt>, but it is more than that: it encourages some
ways of doing things which use specific extensions provided by the shell.
This is the reason why some people call them “bashisms”.</p>
<div class="section">
<h2><a class="toc-backref" href="#id13" id="locality-is-good" name="locality-is-good">Locality is good</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use <tt class="docutils literal"><span class="pre">local</span></tt> to define local variables inside functions.</p>
</div>
<p>When using Bash one can mark shell variables as <em>local</em> in shell functions.
Polluting the global namespace too much is a bad thing, so it is very common
to see code that uses the <tt class="docutils literal"><span class="pre">local</span></tt> keyword in most variable definitions:</p>
<div class="highlight"><pre>say_hello <span class="o">()</span> <span class="o">{</span>
    <span class="c"># The &#39;whom&#39; variable will not be seen outside the function</span>
    <span class="nb">local </span><span class="nv">whom</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="s1">&#39;world&#39;</span><span class="k">}</span>
    <span class="nb">echo</span> <span class="s2">&quot;Hello ${whom}!&quot;</span>
<span class="o">}</span>
</pre></div>
<p>When using built-ins that define the variables themselves (like the
<a class="reference" href="#read-built-in">read built-in</a>) the variables must be marked as local before using the
command:</p>
<div class="highlight"><pre>add_prefix <span class="o">()</span> <span class="o">{</span>
    <span class="nb">local </span>line
    <span class="k">while </span><span class="nb">read </span>line ; <span class="k">do</span>
<span class="k">        </span><span class="nb">echo</span> <span class="s2">&quot;$1 - $line&quot;</span>
    <span class="k">done</span>
<span class="o">}</span>
</pre></div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id14" id="cleaning-up" name="cleaning-up">Cleaning up</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">The <tt class="docutils literal"><span class="pre">unset</span></tt> built-in can be used to delete variables <em>and</em>
function definitions from the environment.</p>
</div>
<p>If you use a temporary variable you can use <tt class="docutils literal"><span class="pre">unset</span></tt> to remove its
definition. For functions it is better to use <a class="reference" href="#locality-is-good">local variables</a> but
sometimes it may be needed to remove items from the environment. This
command will also remove definitions of functions.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id15" id="reading-file-contents" name="reading-file-contents">Reading file contents</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use <tt class="docutils literal"><span class="pre">$(&lt;</span> <span class="pre">...)</span></tt> instead of <tt class="docutils literal"><span class="pre">$(cat</span> <span class="pre">...)</span></tt> when possible.</p>
</div>
<div class="warning">
<p class="first admonition-title">Warning</p>
<p class="last">Keep in mind that <tt class="docutils literal"><span class="pre">$(&lt;</span> <span class="pre">...)</span></tt> will <em>only</em> work when just
reading the contents of a file. If there are a pipeline in the
expansion (e.g. <tt class="docutils literal"><span class="pre">$(cat</span> <span class="pre">foo</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">bar)</span></tt> this shorthand will
render an empty output.</p>
</div>
<p>Reading all the contents of a file in shell code is usually done by using
the <tt class="docutils literal"><span class="pre">cat</span></tt> command in a command expansion. For example we can read the
contents of the password database file with the following snippet:</p>
<div class="highlight"><pre><span class="c"># The usual code for reading files:</span>
<span class="nv">contents</span><span class="o">=</span><span class="k">$(</span>cat /etc/passwd<span class="k">)</span>
</pre></div>
<p>This is a rather common construction that incurs in the <a class="reference" href="#fork-exec">fork+exec</a>
operation. There is an alternative recognized by Bash which produces the
same result but is implemented inside the shell:</p>
<div class="highlight"><pre><span class="c"># This is faster than using &#39;cat&#39;:</span>
<span class="nv">contents</span><span class="o">=</span><span class="k">$(</span>&lt; /etc/passwd<span class="k">)</span>
</pre></div>
<div class="tip">
<p class="first admonition-title"><a id="read-built-in" name="read-built-in">Tip</a></p>
<p class="last">Use the <tt class="docutils literal"><span class="pre">read</span></tt> built-in for processing line-based input.</p>
</div>
<p>Finally, sometimes you need to read a big file (which may even not fit in
memory), but only one line at a time is needed. Imagine you are a spammer
which wants to send a zillion e-mails to a list of addresses. Here the
<tt class="docutils literal"><span class="pre">read</span></tt> builtin fits perfectly: it will read content enough up to
a delimiter (end of line by default). Moreover, its exit code will always
be zero until the end of the input is reached. This way one can easily
parse huge line-based text files:</p>
<div class="highlight"><pre><span class="c"># Read one line at a time, assign it to the &#39;recipient&#39; variable</span>
<span class="c"># and use &#39;sendmail&#39; to spam out people:</span>
<span class="nv">message</span><span class="o">=</span><span class="s1">&#39;Subject: Improve your relations</span>

<span class="s1">Buy V14gr4 online NOW!&#39;</span>

<span class="k">while </span><span class="nb">read </span>myline ; <span class="k">do</span>
<span class="k">    </span>sendmail <span class="s2">&quot;$recipient&quot;</span> &lt;&lt;&lt; <span class="s2">&quot;$message&quot;</span>
<span class="k">done</span> &lt; email-list.txt
</pre></div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id16" id="arrays" name="arrays">Arrays</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Consider using arrays when handling lists of data insteads of lists
with a character separating items.</p>
</div>
<p>Bash includes supports for arrays right away as an extension over
traditional Sh-like shells. Although they are somewhat limited, they are
very useful in some cases. Defining an array and using it is easy:</p>
<div class="highlight"><pre><span class="nv">my_array</span><span class="o">=(</span> item_1 item_2 item_3 <span class="o">)</span>

<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_array</span><span class="p">[1]</span><span class="k">}</span>
<span class="nb">echo</span> <span class="k">${</span><span class="nv">my_array</span><span class="p">[2]</span><span class="k">}</span>
</pre></div>
<p>The limitation of arrays is that it is not possible to have multidimensional
arrays... but they are not needed for most shell tasks after all. This makes
the syntax for adding elements to an array rather funny:</p>
<div class="highlight"><pre><span class="nv">my_array</span><span class="o">=(</span> <span class="s2">&quot;${my_array[@]}&quot;</span> another_element <span class="o">)</span>
</pre></div>
<p>One nice example of using arrays is gathering arguments which will be
further passed to another function or command. It is safer to use an array
rather than a space-separated string: you can have embedded spaces in
command line arguments using arrays, which would screw your program when
using a plain string. For example:</p>
<div class="highlight"><pre><span class="nv">flags</span><span class="o">=(</span> -a <span class="o">)</span>
<span class="o">[</span> -n <span class="s2">&quot;$VERBOSE&quot;</span>  <span class="o">]</span> &amp;&amp; <span class="nv">flags</span><span class="o">=(</span> <span class="s2">&quot;${flags[@]}&quot;</span> --verbose <span class="o">)</span>
<span class="o">[</span> -o <span class="s1">&#39;some file&#39;</span> <span class="o">]</span> || <span class="nv">flags</span><span class="o">=(</span> <span class="s2">&quot;${flags[@]}&quot;</span> -o <span class="s1">&#39;some file&#39;</span> <span class="o">)</span>

run_command <span class="s2">&quot;${flags[@]}&quot;</span>
</pre></div>
<p>The above code will always work as expected, even when the flags have
bizarre characters inside, which would normally confuse the shell. Well, not
the shell but you when trying to debug the problem.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="built-in-trick-galore" name="built-in-trick-galore">Built-in trick galore</a></h2>
<p>Some of the Bash built-in commands have some unusual features which may look
as nonsense, but they serve very concrete purposes and you will be glad of
knowing about them when the time to use them arrives. Some of the commands
are only outlined, so make sure to have the <a class="reference" href="http://www.gnu.org/software/bash/manual/html_node/">Bash manual</a> at hand.</p>
<div class="section">
<h3><a class="toc-backref" href="#id18" id="printf-v" name="printf-v">printf -v</a></h3>
<p>Using the <tt class="docutils literal"><span class="pre">-v</span></tt> flag you output of <tt class="docutils literal"><span class="pre">printf</span></tt> will be assigned to a shell
variable instead of printed to standard output. As an example, the following
two sentences produce the same result, but the second one avoids doing an
extra shell expansions and capturing output for assignment:</p>
<div class="highlight"><pre><span class="nv">version_string</span><span class="o">=</span><span class="k">$(</span><span class="nb">printf</span> <span class="s2">&quot;Bash %i.%02i&quot;</span> <span class="k">${</span><span class="nv">BASH_VERSINFO</span><span class="p">[0]</span><span class="k">}</span> <span class="k">${</span><span class="nv">BASH_VERSINFO</span><span class="p">[1]</span><span class="k">})</span>
<span class="nb">printf</span> -v version_string <span class="s2">&quot;Bash %i.%02i&quot;</span> <span class="k">${</span><span class="nv">BASH_VERSINFO</span><span class="p">[0]</span><span class="k">}</span> <span class="k">${</span><span class="nv">BASH_VERSINFO</span><span class="p">[1]</span><span class="k">}</span>
</pre></div>
<p>This can be very useful in conjunction with <a class="reference" href="#printf-q">printf %q</a>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id19" id="printf-q" name="printf-q">printf %q</a></h3>
<p>The <tt class="docutils literal"><span class="pre">%q</span></tt> specifier formats the given argument in a way that it is reusable
as further shell code input, i.e. to be reused as input for the <tt class="docutils literal"><span class="pre">eval</span></tt>
command, by adding escape sequences to those characters which are interpreted
by the shell. This is very useful with untrusted input supplied by the user
or third party applications:</p>
<div class="highlight"><pre><span class="nb">read</span> -p <span class="s1">&#39;Text: &#39;</span> line
<span class="nb">eval</span> <span class="s2">&quot;foo=&#39;$(printf %q &quot;</span><span class="nv">$line</span><span class="s2">&quot;)&#39;&quot;</span>
</pre></div>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id20" id="caller" name="caller">caller</a></h3>
<p>This will output the line number and file name from which the current
function was called. This can be used to craft your own debugging functions
or printing backtraces when an error occurs.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id21" id="declare" name="declare">declare</a></h3>
<p>Being declarative and using <tt class="docutils literal"><span class="pre">declare</span></tt> means that Bash will be able of
producing better error messages and do some basic type checking.</p>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">When <tt class="docutils literal"><span class="pre">declare</span></tt> is used inside a function, it declares local
variables, like <tt class="docutils literal"><span class="pre">local</span></tt> does.</p>
</div>
<p>Quick summary of available flags, which can be used with <tt class="docutils literal"><span class="pre">local</span></tt> as well:</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-a</span></kbd></td>
<td>Declare arrays.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-f</span></kbd></td>
<td>Declare functions.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-i</span></kbd></td>
<td>Declare integers.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-r</span></kbd></td>
<td>Set variables as read-only. Assigning new values will produce an error.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-t</span></kbd></td>
<td>Mark functions to trigger the <tt class="docutils literal"><span class="pre">DEBUG</span></tt> and <tt class="docutils literal"><span class="pre">RETURN</span></tt> traps when called.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-x</span></kbd></td>
<td>Variables are exported to subshells. This is similar to use <tt class="docutils literal"><span class="pre">export</span></tt>.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id22" id="use-the-source-luke" name="use-the-source-luke">Use the <em>source</em>, Luke</a></h2>
<div class="tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use <tt class="docutils literal"><span class="pre">source</span></tt> as it is clearer than <tt class="docutils literal"><span class="pre">.</span></tt> (dot).</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">source</span></tt> keywords works exactly the same way as <tt class="docutils literal"><span class="pre">.</span></tt> (dot): it reads
a file containing shell code in the current context (i.e. without invoking
a subshell). Apart from being longer, <tt class="docutils literal"><span class="pre">source</span></tt> is easier in the eyes and
makes clear that one wants to read <em>source</em> code.</p>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id23" id="philosophy-basics" name="philosophy-basics">Philosophy basics</a></h1>
<p>And now for something completely different: a quick tour on <a class="reference" href="http://www.faqs.org/docs/artu/ch01s06.html">The Unix
Philosophy</a>. Having a quick
summary of the basics at hand is, er, <em>handy</em>. As we are dealing with the
shell, which is an angular piece of Unix, it is nice to review some of the
precepts which make it a great operating system, and apply them to the
shell. Alas, some of them are of particular interest for shell programming.
In no particular order:</p>
<dl class="docutils">
<dt>Rule of Modularity</dt>
<dd>Write simple parts connected by clean interfaces.</dd>
<dt>Rule of Composition</dt>
<dd>Design programs to be connected to other programs.</dd>
<dt>Rule of Extensibility</dt>
<dd>Design for the future, because it will be here sooner than you
think.</dd>
<dt>Rule of Silence</dt>
<dd>When a program has nothing surprising to say, it should say nothing.</dd>
<dt>Rule of Repair</dt>
<dd>When something must fail, fail noisily and as soon as possible.</dd>
<dt>Rule of Clarity</dt>
<dd>Clarity is better than cleverness.</dd>
</dl>
<!-- vim: expandtab filetype=rst shiftwidth=4 tabstop=4 spell spelllang=en -->
</div>
</div>
</body>
</html>
