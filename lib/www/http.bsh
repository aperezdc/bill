#! /usr/bin/env bill
#++
#   ==================
#   Simple HTTP server
#   ==================
#   :Author: Adrian Perez <aperez@igalia.com>
#   :License: GPL v2
#   :Copyright: 2008 Igalia S.L.
#   :Abstract: Provides a not-so-basic standalone web server.
#       Socket functionality is **not** provided. Requests are
#       read from standard input, responses are sent to standard
#       output and logging is done the standard error stream.
#
#   .. contents::
#--

use data/map
use text/string
use text/template

need sed || die "The 'sed' program was not found"
need cat || die "The 'cat' program was not found"

#++
#   Running a webserver
#   ===================
#   Fortunately, dealing with sockets can be done in pure Bash [#]_.
#   Unfortunately enough, some distributors choose not to enable support for
#   this feature. This is the case of the Bash builds included with Debian_
#   and Ubuntu_.
#
#   .. [#] http://unixjunkie.blogspot.com/2006/01/two-cool-bash-tricks.html
#   .. _debian: http://debian.org
#   .. _ubuntu: http://ubuntulinux.org
#
#
#   Using auxiliar tools
#   --------------------
#   Some utilities exist which allow nearly all program
#   using the standard input and output streams to use sockets. It is likely
#   that at least one of these is available for your operating system of
#   choice. All those examples run a simple web server listening in port
#   ``8000`` at ``127.0.0.1`` (the loopback network address). Once you try
#   one of those command lines, point a browser to http://localhost:8000/doc
#   and you will be able of browsing the Bill documentation using the simple
#   built-in web server.
#
#   .. class:: tabular
#
#   ========== =============================================================
#   Package    Command
#   ========== =============================================================
#   ipsvd_     ``tcpsvd 127.0.0.1 8000 ./scripts/bill lib/www/http.bsh``
#   ucspi-tcp_ ``tcpserver -q 127.0.0.1 8000 ./scripts/bill lib/www/http.bsh``
#   netcat_    ``(while true ; do nc -l -p 8000 -c './scripts/bill lib/www/http.bsh'; done)``
#   netpipes_  ``faucet 8000 -H 127.0.0.1 -i -o ./scripts/bill lib/www/http.bsh``
#   ========== =============================================================
#
#   .. _ipsvd: http://smarden.org/ipsvd/
#   .. _ucspi-tcp: http://cr.yp.to/ucspi-tcp.html
#   .. _netcat: http://netcat.sourceforge.net/
#   .. _netpipes: http://web.purplefrog.com/~thoth/netpipes/netpipes.html
#
#   .. note:: Commands should be run from the top-level Bill source
#       directory, otherwise they may not work.
#
#   .. warning:: The netcat_ command is very flaky, it will not accept
#       concurrent connections, and in general will perform poorly.
#--

#++
#   Functions
#   =========
#--


http_response_by_code=(
    200  'Ok - Transceiver and a coke, please'
    403  'Forbidden'
    404  'Not Found'
    500  'Internal Server Error'
    501  'Not Implemented'
)


http_error_document_template='<html>
  <head>
    <title>Error: ${err_text}</title>
    <style type="text/css">
    pre {
        font-family: monospace;
        background: #f8f8f8;
        border: 1px solid #eee;
        padding: 1em;
    }
    </style>
  </head>
  <body>
    <h1>${err_text}</h1>
    <p>Additional information:</p>
    <pre>${err_description}</pre>
  </body>
</html>'


http_CR=$(printf "\015")


http_mime_mapping=(
    bsh  text/plain
    txt  text/plain
    rst  text/plain
    conf text/plain

    html text/html
    htm  text/html

    css  text/css

    png  image/png

    jpg  image/jpeg
    jpe  image/jpeg
    jpeg image/jpeg
)


#++ http_mimetype_guess path
#
#   Determines MIME types depending on the entries of a hash map named
#   ``http_mime_mapping``, which contains a default set of entries which
#   suffice for serving the Bill documentation. The suffix of the file
#   pointed by ``path`` is used to determine its content type.
#
#   For example:
#
#   .. sourcecode:: bash
#
#       (bill) http_mimetype_guess /etc/sysctl.conf
#       text/plain
#
#--
http_mimetype_guess ()
{
    local mime=$(map_get http_mime_mapping "${1##*.}")
    if [ "$mime" ]
    then
        echo "$mime"
    else
        echo "application/octet-stream"
    fi
}


#++ http_error_document [ code [ description ... ] ]
#
#   Generates an error document in standard output:
#
#   * ``code`` is the HTTP error code (default is ``500``)
#   * ``description`` is an arbitrary piece of text which will be inserted
#     pre-formatted in the output.
#
#--
http_error_document ()
{
    local mess=$(map_get http_response_by_code $1)
    shift
    local desc=$(string_join $'\n' "$@")
    [[ -z $desc ]] && desc='No additional information supplied'

    var_err_number=$1       \
    var_err_text=$mess       \
    var_err_description=$desc \
        template_expand <<< "$http_error_document_template"
}



#++ http_error [ code [ description ... ] ]
#
#   Sends an HTTP error status code and an accompanying HTML document
#   explaining the error. Error document is formatted using
#   http_error_document_.
#--
http_error ()
{
    http_log_stderr "$@"
    printf "HTTP/1.0 %s %s\r\n" $1 "$(map_get http_response_by_code $1)"
    printf "Content-Type: text/html\r\n"
    printf "Connection: close\r\n"
    printf "\r\n"
    http_error_document "$@"
}


#++ http_redirect uri [ code ]
#
#   Sends an HTTP redirection, to the given ``uri``. If not supplied, the
#   ``code`` will be ``302`` (a permanent redirect). You can pass ``301``
#   for temporary redirects. Keep in mind that using absolute paths in
#   redirects is recommended.
#--
http_redirect ()
{
    http_log_stderr "${2:-302}"
    printf "HTTP/1.0 ${2:-302}\r\n"
    printf "Location: $1\r\n"
    printf "Connection: close\r\n"
    printf "\r\n"
}


#++ http_log_stderr [ arg1 [ arg2 ... [ argN ] ] ]
#
#   Logs a line of output to standard error. Log format is as follows::
#
#       <method> <path> HTTP/<version> - arg1 arg2 ... argN
#
#   Note that timestamps are not added to output. This is left as is
#   intentionally: it is nicer to add a filter in standard output which
#   does further formatting of logged text, and we do not have to mess
#   with date formatting.
#--
http_log_stderr ()
{
    local mess=$(string_join ' ' "$@")
    echo "$REQUEST_METHOD $PATH_INFO $HTTP_VERSION - $mess" 1>&2
}



http_directory_template='#! local var_i
<html>
  <head>
    <title>${path}</title>
  </head>
  <body>
    <h1>${path}</h1>
    <ul>
    $([ "${path}" = "/" ] || echo "<li><a href=\\\"../\\\">[up]</a></li>")
    $(for var_i in ".${path}"* ; do \
        echo "<li><a href=\\\"${i:1}\\\">${i#.${path}}</a></li>" ; \
    done)
    </ul>
  </body>
</head>'


#++ http_handle_GET
#
#   Default handler for the HTTP ``GET`` method. This does nothing more than
#   serving static files and producing directory listings. Also, if path
#   resolves to a directory which contains a file named ``index.html`` it
#   will be served instead.
#--
http_handle_GET ()
{
    local isdir=false

    if ! [ -r "./$PATH_INFO" ]
    then
        http_error 404 "path=$PATH_INFO"
        return 1
    fi

    if [ -d "./$PATH_INFO" ]
    then
        if ! string_endswith "$PATH_INFO" "/"
        then
            http_redirect "$PATH_INFO/"
            return
        fi

        if [ -r "./$PATH_INFO/index.html" ]
        then
            PATH_INFO="${PATH_INFO}/index.html"
        else
            isdir=true
        fi
    fi

    printf "HTTP/1.0 200 Ok\r\n"
    printf "Connection: close\r\n"
    if $isdir
    then
        printf "Content-Type: text/html; encoding=utf-8\r\n"
        printf "\r\n"
        var_path=$PATH_INFO template_expand <<< "$http_directory_template"
    else
        printf "Content-Type: %s\r\n" "$(http_mimetype_guess "./$PATH_INFO")"
        printf "\r\n"
        cat "./$PATH_INFO"
    fi
}


#++ http_handle_request [ handler_prefix ]
#
#   Serves a single HTTP request. The following variables are set by the
#   function and their values **will be clamped** if already defined. Note
#   that most of them start with the ``HTTP_`` prefix or have names of the
#   variables used by the `CGI interface`_:
#
#   * REQUEST_METHOD
#   * PATH_INFO
#   * QUERY_STRING
#   * ...and so on.
#
#   .. _cgi interface: http://www.w3.org/CGI/
#
#   The ``handler_prefix`` can be used to change behavior of how requests
#   are served. It is used to find which functions are used to serve the
#   different HTTP methods. As an example, one could define:
#
#   .. sourcecode:: bash
#
#       my_handler_GET () {
#           # Do something interesting...
#       }
#       my_handler_HEAD () {
#           # ...and something *even* more interesting.
#       }
#
#   and then use ``my_handler`` as prefix, then the HTTP request hadler will
#   pass ``GET`` to ``my_handler_GET`` and ``HEAD`` ones to
#   ``my_handler_HEAD``. This allows for easily reusing the HTTP module.
#--
http_handle_request ()
{
    local prefix=${1:-'http_handle'}

    # Use CGI variables as log as possible, so interfacing with external
    # CGIs will be easier.
    #
    local REQUEST_METHOD PATH_INFO QUERY_STRING HTTP_VERSION
    local readmore line key val

    read REQUEST_METHOD PATH_INFO HTTP_VERSION
    # String annoying carriage return characters
    REQUEST_METHOD=$(string_upper "${REQUEST_METHOD%${http_CR}}")
    HTTP_VERSION=$(string_upper "${HTTP_VERSION%${http_CR}}")
    PATH_INFO=${PATH_INFO%${http_CR}}
    QUERY_STRING=${PATH_INFO#*\?}
    PATH_INFO=${PATH_INFO%%\?*}

    export REQUEST_METHOD PATH_INFO HTTP_VERSION QUERY_STRING

    case $HTTP_VERSION in
        HTTP/1.0 | HTTP/1.1)
            readmore=true
            ;;
        HTTP/0.9 | "")
            readmore=false
            ;;
        *)
            http_error 500 "Protocol version unrecognized"
            return
            ;;
    esac

    local handler="${prefix}_${REQUEST_METHOD}"
    if [[ $(type -t "$handler") != 'function' ]]
    then
        http_error 501 "Method $REQUEST_METHOD not implemented"
        return
    fi

    while $readmore
    do
        read line
        if [[ $line = $http_CR ]] || [[ -z $line ]]
        then
            # We have found the last empty line signaling end of headers.
            readmore=false
            break
        fi

        # TODO: Handle multi-line HTTP headers (check RFC for details)
        line=${line%${http_CR}}
        key=$(string_lower "${line%%:*}")
        val=$(echo "${val#*:}" | sed -e 's:^[[:space:]]*::')
        eval "export HTTP_${key//-/_}='${val//\'/\\\'}'"
    done

    $handler && http_log_stderr 200 "$handler"
}


main http_handle_request

