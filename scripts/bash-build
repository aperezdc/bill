#! /usr/bin/env bill

use ui/cli
use dev/tty
use data/hash


cmdline=(
    s:site       'http://ftp.gnu.org/gnu/bash' 'Download site for Bash'
    p:patch      true                          'Apply official patches'
    l:patchlevel '39'                          'Hightest patch number'
    v:version    '3.2'                         'Bash version to build'
    f:fetch      false                         'Fetch only'
    d:workdir    'bash-build-tmp'              'Working directory'
)
options=$(hash_new)

C=$(tty_color_fg yellow)
R=$(tty_color_fg reset)

have () {
    need "$@"
}


fetch ()
{
    local -r dest=$(hash_get $options workdir)
    local -r site=$(hash_get $options site)
    local ret=0

    [[ -d $dest ]] || mkdir "$dest"
    pushd "$dest" > /dev/null

    if have wget ; then
        wget --quiet "$site/$1" || ret=1
    elif have curl ; then
        curl --silent --insecure --location \
             --remote-name --progress-bar "$site/$1" || ret=1
    else
        die "None of 'curl' or 'wget' are available"
    fi

    popd > /dev/null
    return $ret
}


fetch_source ()
{
    local -r src="$1"
    local sig="$1.sig"

    if ! [[ -r $src ]] ; then
        fetch "$src"
    fi
    [[ -r $sig ]] || fetch "$sig"

    sig=${sig##*/}
}


fetch_tarball ()
{
    local -r pkgname="bash-$(hash_get $options version).tar.gz"
    fetch_source "$pkgname"
}


fetch_patches ()
{
    local -r version=$(hash_get $options version)
    local -r format="bash-$version-patches/bash${version//./}-%03i"
    local -r level=$(hash_get $options patchlevel)
    local i

    for (( i = 1; i <= level; i++ )) ; do
        fetch_source "$(printf "$format" $i)"
    done
}


gpg_verify ()
{
    :
}


prepare_gpg ()
{
    local -r workdir=$(hash_get $options workdir)

    [[ -d $workdir ]] || mkdir "$workdir"
    pushd "$workdir" > /dev/null

    local lock_dir=_sh30595
    local echo=echo
    if test ! -d ${lock_dir}
    then : ; else ${echo} 'lock directory '${lock_dir}' exists'
        exit 1
    fi
    if mkdir ${lock_dir}
    then : ; else ${echo} 'failed to create lock directory'
        exit 1
    fi
    # ============= trustedkeys.gpg ==============
    sed 's/^X//' << 'SHAR_EOF' > 'trustedkeys.gpg' &&
XÂ™Â¢AÂ°l
XyÃ«Ã\Ã‚Â ;Ã›Â›Ã†IÃ‘Ã”Ã‹*GÂ¢Ã¥tÃ†Â…Â°ÂºFÃªÂ©rÃ‰Â¶Â•>Â¢@TÂªÂ…ÂÂ’Â…Â±Â‰Â†Â‚IÃ¼ÃÃ˜Â¹Ã»Â¦grÂ³WÃ‰Â…Ãˆ)Ã½Ã•Â`Â£weÃ‰O
XÂªUÂ¡ Ã­KÂ“+}"Â—OÃ±Ã£8Ã´4Ã€	;-Â£Ã™lÃ>9Ã¹Â¦Â¡Â„_Ã—Ã¬C
XÃ¬Â®Â¶Ã[rÃ¿hÃˆÂ«Ã“xC	Ã¬Ã7TÂ—VriÃ»Â€Ã«Â´&HÃ˜RÂ¡]SÃ¢Ã³Ã¶Ã•gÃ»Â™Ã¢$J@Â³rS-0
XPÂ‹Â‹RÃŠÃ‡sÃ¸Ã ÃÃ½Â±Ã˜W2ÃšÃ£Â¶Â”Â@Ã“mÃ»x6neÃ Â–Â…Â¦[Â—Ã¬Â›Ã·bÃ§AÂ¦Ã–]MkÂ­ÃÃtÃ‘'Â…BÂ‹:XLPqÃ“*z)yn\Â²Ãˆf+D$Â´Chet Ramey <chet@cwru.edu>ÂˆF
X	Â’%Ã ,BÂ¸y 
X	Â»XiÃ°dÃªtÂ«ÃÃ
X	Â»XiÃ°dÃªtÂ«Ã£p
SHAR_EOF
    :
    if test $? -ne 0
    then ${echo} 'restore of trustedkeys.gpg failed'
    fi
    if ! rm -fr ${lock_dir}
    then
        popd > /dev/null
        return 1
    fi

    popd > /dev/null
}


run_build ()
{
    cli_optparse -h cmdline $options "$@"

    prepare_gpg
    fetch_tarball
    if $(hash_get $options patch) ; then
        fetch_patches
    fi
    if $(hash_get $options fetch) ; then
        return
    fi
}

main run_build


